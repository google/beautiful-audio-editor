# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Build tool for the audio cat editor.
Only works if run from home directory.
"""

import hashlib
import json
import os
import re
import shutil
import sys
import datetime

PYTHON_LICENSE = """
# Copyright 2016 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""".lstrip()

JS_LICENSE = """
/**
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
""".lstrip()

HTML_LICENSE = """
<!--
Copyright 2016 Google Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
""".lstrip()

def make_system_call(unix_command):
  """Calls a command in the shell."""
  os.system(unix_command)

def fixjsstyle():
  """Automatically tries to fix javascript style mishaps."""
  make_system_call("""
      fixjsstyle -r src/js/original
    """)

def retrieve_file_list_string(grep_search_string):
  """Retrieves a shell command for obtaining a list of files based on the grep
      search string.
  """
  return '$(find src/js/original -iname ' + grep_search_string + \
      ' -type f -print0 | xargs -0 echo)'

def retrieve_all_gss_files_string():
  return retrieve_file_list_string('*.gss')

def create_uncompiled_stylesheet():
  """Creates an uncompiled, un-renamed stylesheet for debug mode."""
  print ('Generating uncompiled CSS ...')
  gss_file_list_string = retrieve_all_gss_files_string()
  make_system_call("""
      java -jar third_party/closure_stylesheets/closure-stylesheets-20111230.jar \
          --allowed-unrecognized-property user-select src/js/original/app/app.gss \
          --pretty-print %s > build/css/debug.css;
    """ % gss_file_list_string)

def compile_stylesheets():
  """Compiles GSS style sheet files."""
  print ('Compiling CSS ...')
  rename_map_file_name = 'renaming_map.js'
  mobile_compile = False
  for word in sys.argv[2:]:
    if word == 'mobile':
      mobile_compile = True
      rename_map_file_name = 'renaming_map_mobile.js'
  gss_file_list_string = retrieve_all_gss_files_string()
  autogenerated_directory = 'src/js/auto_generated/'
  rename_mapping_file = autogenerated_directory + rename_map_file_name
  try:
    os.remove(autogenerated_directory + 'renaming_map.js')
  except OSError:
    # The file doesn't exist in the first place ...
    pass
  try:
    os.remove(autogenerated_directory + 'renaming_map_mobile.js')
  except OSError:
    # The file doesn't exist in the first place ...
    pass

  make_system_call("""
      java -jar third_party/closure_stylesheets/closure-stylesheets-20111230.jar \
          --output-renaming-map-format CLOSURE_COMPILED \
          --allowed-unrecognized-property user-select src/js/original/app/app.gss \
          --rename CLOSURE \
          --output-renaming-map %(rename_mapping_file)s \
          --output-file build/css/%(css_file_name)s.css %(gss_file_list_string)s;
    """ % {
        'css_file_name': 'cm' if mobile_compile else 'c',
        'rename_mapping_file': rename_mapping_file,
        'gss_file_list_string': gss_file_list_string,
      })
  # Prepend a require so that the compiler considers the name mapping.
  make_system_call("""
      echo "goog.provide('audioCat.Css%(environment_prefix)sRenameMapping');$(cat %(rename_mapping_file)s)" > %(rename_mapping_file)s
    """ % {
        'environment_prefix': 'Mobile' if mobile_compile else '',
        'rename_mapping_file': rename_mapping_file,
      })

def compile_templates():
  """Compiles soy templates."""
  print ('Compiling soy templates ...')
  soy_file_list_string = retrieve_file_list_string('*.soy')
  make_system_call("""
      java -jar third_party/closure_templates/SoyToJsSrcCompiler.jar \
           --cssHandlingScheme GOOG \
           --outputPathFormat 'src/js/auto_generated/compiled_templates/{INPUT_FILE_NAME_NO_EXT}_generated_template.js' \
           --shouldProvideRequireSoyNamespaces \
           %s
    """ % soy_file_list_string)

def compile_javascript():
  """Compiles the javascript."""
  print ('Compiling javascript ...')
  call = 'java -client -jar third_party/closure_compiler/compiler.jar '
  keywords = {}
  mobile_compile = False
  binary_name = 'c.js'
  environment_prefix = ''
  deps_file_name = 'deps.js'
  for word in sys.argv[2:]:
    if word == 'mobile':
      call += '--define="FLAG_MOBILE=true" '
      mobile_compile = True
      deps_file_name = 'deps-mobile.js'
      binary_name = 'cm.js'
      environment_prefix = 'Mobile'
  externs_directory = 'third_party/closure-externs'
  deps_file_path = 'build/js/' + deps_file_name
  call += "--js " + deps_file_path + " "
  call += "--js 'src/js/original/utility/compiler-flags.js' "
  js_directories = [
      'third_party/closure_library/closure',
      'third_party/closure_templates/js',
      'src/js'
    ]
  for directory_name in js_directories:
    for root, dirnames, filenames in os.walk(directory_name):
      for filename in filenames:
        if filename.endswith('.js'):
          call += '--js ' + os.path.join(root, filename) + ' '
  # Compile and optimize as much as possible.
  call += '--compilation_level=ADVANCED_OPTIMIZATIONS '
  # If you want to debug with pretty-printed, uncompiled code, use this instead.
  # call += '--compilation_level=WHITESPACE_ONLY '
  # call += '--formatting=PRETTY_PRINT '

  call += '--warning_level=VERBOSE '
  call += '--jscomp_warning=checkTypes '
  call += '--jscomp_warning=lintChecks '
  call += '--jscomp_error=accessControls '
  call += '--jscomp_error=ambiguousFunctionDecl '
  call += '--jscomp_error=checkTypes '
  call += '--jscomp_error=constantProperty '
  call += '--jscomp_error=duplicateMessage '
  call += '--jscomp_error=globalThis '
  call += '--jscomp_error=invalidCasts '
  call += '--jscomp_error=missingProperties '
  call += '--jscomp_error=nonStandardJsDocs '
  call += '--jscomp_error=typeInvalidation '
  call += '--jscomp_error=undefinedNames '
  call += '--jscomp_error=unknownDefines '
  call += '--jscomp_error=uselessCode '
  call += '--jscomp_error=visibility '
  call += '--warning_level=VERBOSE '
  call += '--common_js_entry_module=src/js/original/app/main.js '
  call += '--only_closure_dependencies '
  call += '--closure_entry_point=app.Main '
  call += '--closure_entry_point=audioCat.Css' + environment_prefix + 'RenameMapping '
  # Add externs.
  call += ' '.join(['--externs ' + os.path.join(externs_directory, file_name) + ' ' for file_name in filter(lambda n: n.endswith('.js'), os.listdir(externs_directory))])
  call += ' > build/js/' + binary_name
  make_system_call(call)

def generate_deps():
  """Generates a dependencies list so we can view the app in uncompiled mode."""
  # Generate a debug version of the CSS as well.
  print ('Generating dependencies ...')
  deps_file_name = 'deps.js'
  for word in sys.argv[2:]:
    if word == 'mobile':
      deps_file_name = 'deps-mobile.js'
  build_directory_path = 'build/js/'
  deps_file_path = build_directory_path + deps_file_name

  try:
    os.remove(build_directory_path + 'deps.js')
  except OSError:
    # The file doesn't exist in the first place ...
    pass
  try:
    os.remove(build_directory_path + 'deps-mobile.js')
  except OSError:
    # The file doesn't exist in the first place ...
    pass
  create_uncompiled_stylesheet()
  make_system_call("""
      third_party/closure_library/closure/bin/build/depswriter.py  \
        --root_with_prefix="src/js ../../../../src/js" \
        --root_with_prefix="third_party/closure_templates/js ../../../../third_party/closure_templates/js" \
        > %(deps_file_path)s ;
    """ % {
      'deps_file_path': deps_file_path
    })

def build_client():
  """Builds the compiled version of the entire application."""
  compile_stylesheets()
  compile_templates()
  generate_deps()
  compile_javascript()

def update_manifest():
  """Updates the version number in the manifest for the Chrome app."""
  print ('Writing Google manifest ...')
  manifest_file_name = 'manifest.json'
  chrome_app_directory = 'build/chrome-app/'
  manifest_path = chrome_app_directory + manifest_file_name
  manifest_file = open(manifest_path)
  content = manifest_file.read()
  manifest_file.close()
  version_string_match = re.search(r'"version":\s?"(.+)"', content)
  version_string = version_string_match.group(1)
  last_number = version_string.split('.')[-1]
  new_last_number = int(last_number) + 1
  new_version_string = \
      version_string[0:len(version_string) - len(last_number)] + \
          str(new_last_number)
  new_content = content.replace(
      '"' + version_string + '"', '"' + new_version_string + '"')
  new_manifest_file = open(manifest_path, 'w+')
  new_manifest_file.write(new_content)
  new_manifest_file.close()
  make_system_call("""
      zip -j %s %s media/*.gif >> /dev/null
    """ % (chrome_app_directory + 'chromeApp', chrome_app_directory + '*'))

def copy_build_to_server():
  """Copies static files including compiled js and css to the server."""
  print ('Copying third_party js into build/js ...')
  third_party_js_dir = 'third_party/js'
  files = os.listdir(third_party_js_dir)
  for f in files:
    if not f.endswith('.js'):
      continue
    shutil.copyfile(
        os.path.join(third_party_js_dir, f), os.path.join('build/js', f))
  print ('Copying files to local app server ...')
  files_to_ignore = {
    '.DS_Store': 1,
    'README.md': 1,
    'debug.css': 1
  }
  src_dir_root = 'build'
  dest_dir_root = 'src/python/audiocatapp/static'
  # Copy our compiled js binary, then other static files.
  files_to_manifest = ['/', 'app', 'docs', 'css/static.css']
  src_js_dir = os.path.join(src_dir_root, 'js')
  dest_js_dir = os.path.join(dest_dir_root, 'js')
  white_listed_scripts = ['c', 'cm', 'lame']
  for script in white_listed_scripts:
    script += '.js'
    original_location = os.path.join(src_js_dir, script)
    if not os.path.exists(original_location):
      continue
    shutil.copyfile(original_location, os.path.join(dest_js_dir, script))
    files_to_manifest.append(os.path.join('js', script))
  copy_dirs = ['css', 'images', 'media']
  dirs_to_exclude_in_cache = ['media']
  for dir_to_copy in copy_dirs:
    src_dir = os.path.join(src_dir_root, dir_to_copy)
    dest_dir = os.path.join(dest_dir_root, dir_to_copy)
    files = os.listdir(src_dir)
    for f in files:
      if f not in files_to_ignore:
        shutil.copyfile(os.path.join(src_dir, f), os.path.join(dest_dir, f))
        if dir_to_copy in dirs_to_exclude_in_cache:
          # Exclude files in this directory from the cache manifest.
          continue
        files_to_manifest.append(os.path.join(dir_to_copy, f))
  # Copy over the contents of build/compiled.html
  copy_html_to_server()

  # Make sure all paths begin with '/'.
  for i, name in enumerate(files_to_manifest):
    if not name.startswith('/'):
      files_to_manifest[i] = '/' + name

  # We no longer create a cache manifest. We use service workers to allow for
  # offline access.
  raw_service_worker_script_name = 'service-worker.js'
  raw_service_worker_script = os.path.join(
      'src/raw_scripts', raw_service_worker_script_name)
  service_worker_read = open(raw_service_worker_script)
  content = service_worker_read.read()
  service_worker_read.close()
  version_string_match = re.search(r'CACHE_VERSION_(\d+)', content)
  old_version = int(version_string_match.group(1))
  new_version = old_version + 1
  content = content.replace(
      'CACHE_VERSION_' + str(old_version), 'CACHE_VERSION_' + str(new_version))
  with open(raw_service_worker_script, 'w+') as output:
    # Update the previous file with a new version.
    output.write(content)
  content = content.replace('URLS_TO_CACHE', json.dumps(files_to_manifest))
  output_name = os.path.join(
      'src/python/audiocatapp/static/js',
      raw_service_worker_script_name)
  with open(output_name, 'w+') as output:
    output.write(content)

  # TODO: Configure app engine to access /service_worker.js.
  # TODO: Remove manifest=... from the HTML.
  # TODO: Move the service worker JS to the app engine dir.

  # Write the cache manifest file.
  # manifest_file = open(os.path.join(dest_dir_root, 'cache.mf'), 'w+')
  # changed_token = str(datetime.datetime.now())
  # manifest_file.write("CACHE MANIFEST\n" + '# ' + changed_token + "\n\n")
  # manifest_file.write("\n".join(files_to_manifest) + "\n")
  # manifest_file.write("https://fonts.googleapis.com/css?family=Open+Sans:300italic,400,300,700")
  # manifest_file.write("\n\n")
  # manifest_file.write("NETWORK:\n *\n")
  # manifest_file.close()

def copy_html_to_server():
  '''Copies over HTML of the app to the local server.'''
  # Open the python file to write o.
  breaks = "\n\n"
  triple_quotes = "'''"
  app_content_file = open('src/python/audiocatapp/app_content.py', 'r+')

  token = '### Autogenerated Content ###'
  header_portion = app_content_file.read().split(token)[0]
  app_content_file.seek(0)
  app_content_file.write(header_portion + token + breaks)

  # Grab and write the desktop file data.
  html_file = open('build/compiled.html')
  html = html_file.read()
  html_file.close()
  app_content_file.write(
      'DESKTOP_APP_CONTENT = ' + triple_quotes + html + triple_quotes + breaks)

  # Grab and write the mobile file data.
  html_file = open('build/compiled-mobile.html')
  html = html_file.read()
  html_file.close()
  app_content_file.write(
      'MOBILE_APP_CONTENT = ' + triple_quotes + html + triple_quotes + breaks)

  # Done writing. Close file.
  app_content_file.close()

def prepare_web_view_files():
  '''Copies files to serve from a web view into the relevant directory.'''
  print ('Aggregating web view files ...')
  build_dir = 'build'
  web_view_dir_name = 'webview-files'
  full_web_view_path = os.path.join(build_dir, web_view_dir_name)
  # Copy over images.
  src_image_dir_path = os.path.join(build_dir, 'images')
  dest_image_dir_path = os.path.join(full_web_view_path, 'images')
  image_files = os.listdir(src_image_dir_path)
  for f in image_files:
    shutil.copyfile(os.path.join(src_image_dir_path, f), os.path.join(dest_image_dir_path, f))
  # Copy over CSS and javascript.
  css_file = 'css/c.css'
  shutil.copyfile(os.path.join(build_dir, css_file), os.path.join(full_web_view_path, css_file))
  js_files = ['js/cm.js', 'js/la.js', 'js/lame.js']
  for f in js_files:
    shutil.copyfile(os.path.join(build_dir, f), os.path.join(full_web_view_path, f))
  # Copy over the HTML page.
  shutil.copyfile(
      os.path.join(build_dir, 'compiled-mobile.html'),
      os.path.join(full_web_view_path, 'cm.html'))
  # Create a manifest file for the mobile page.
  files_to_manifest = []
  # Specify files to exclude from the manifest.
  files_to_exclude_from_manifest = {
    'README.md': True,
    '.DS_Store': True,
    'mobile_cache.mf': True,
  }
  for root, dirs, files in os.walk(full_web_view_path):
    # Take out the build portion from the manifest listed path.
    build_portion = 'build/webview-files/'
    base_dir = root[len(build_portion):]
    for file_name in files:
      if file_name not in files_to_exclude_from_manifest:
        # This file is not to be excluded. Include in manifest.
        files_to_manifest.append(os.path.join(base_dir, file_name))
  manifest_file = open(
      os.path.join(full_web_view_path, 'mobile_cache.mf'), 'w+')
  changed_token = str(datetime.datetime.now())
  manifest_file.write("CACHE MANIFEST\n" + '# ' + changed_token + "\n\n")
  manifest_file.write("\n".join(files_to_manifest) + "\n")
  manifest_file.write("https://fonts.googleapis.com/css?family=Open+Sans:300italic,400,300,700")
  manifest_file.write("\n\n")
  manifest_file.write("NETWORK:\n *\n")
  manifest_file.close()
  # TODO(chizeng): Generate custom manifest file.
  # Copy over the files to app engine.
  app_engine_web_view_dir_path = os.path.join(
      'src/python/audiocatapp/static', web_view_dir_name)
  if os.path.isdir(app_engine_web_view_dir_path):
    # Delete the previous directory if it exists.
    shutil.rmtree(app_engine_web_view_dir_path)
  # We are free to copy over files now that we know dest doesn't exist.
  shutil.copytree(
      full_web_view_path, app_engine_web_view_dir_path)

def set_server():
  copy_build_to_server()

def prepend_license():
  print ("Preprending Apache 2.0 licenses to blocks of code ...")
  directories = ['build', 'src/js/original', 'src/python']
  for directory_name in directories:
    for root, dirnames, filenames in os.walk(directory_name):
      for filename in filenames:
        if filename.endswith('.js') or filename.endswith('.gss'):
          license_string = JS_LICENSE
        elif filename.endswith('.html'):
          license_string = HTML_LICENSE
        elif filename.endswith('.py'):
          license_string = PYTHON_LICENSE
        else:
          # We lack a license for this file.
          continue
        file_location = os.path.join(root, filename)
        readable = open(file_location)
        contents = readable.read()
        readable.close()
        if 'Licensed under the Apache License, Version 2.0' in contents:
          # This file already has a license block. Do not give it another one.
          continue

        writeable = open(file_location, 'w+')
        writeable.write(license_string)
        writeable.write(contents)
        writeable.close()

def aggregate_tests():
  '''Aggregates the list of all tests into a file.'''
  print ('Aggregating all tests into auto_generated/all_tests.js.')
  test_html_files = []
  for root, directories, files in os.walk('src/js/original'):
    for file in files:
      if file.endswith("_test.html"):
        # Pre-pend with '/' so that
        test_html_files.append(os.path.join(root, file))
  with open('src/js/auto_generated/all_tests.js', 'w+') as output_file:
    output_file.write('var _allTests = ' + json.dumps(test_html_files) + ';')

def build():
  '''Builds the client, then copies relevant files to the local server.'''
  build_client()
  set_server()
  aggregate_tests()
  update_manifest()

  for word in sys.argv[2:]:
    if word == 'mobile':
      # We're compiling for mobile. Take special action.
      prepare_web_view_files()

# Mapping from do build command string to shell command.
commands = {
  'android': prepare_web_view_files,
  'build': build, # Builds the client js, then copies over to local server.
  'client': build_client, # Builds client js.
  'compile_css': compile_stylesheets, # Compiles CSS for production.
  'compile_javascript': compile_javascript, # Builds the javascript for prod.
  'compile_templates': compile_templates, # Compiles soy templates into js.
  'fixjsstyle': fixjsstyle, # Fixes js style issues.
  'manifest': update_manifest, # Updates the manifest with a new version number.
  'prepend_license': prepend_license, # Prepends Apache 2.0 license to code.
  'server': set_server, # Copies files to the local app engine app.
  'update_deps': generate_deps, # Generates js dependencies for local debugging.
}

if __name__ == '__main__':
  DEFAULT_COMMAND = 'build'
  shell_parameters = sys.argv
  num_shell_parameters = len(shell_parameters)

  if num_shell_parameters == 1:
    # Set the default command.
    command = DEFAULT_COMMAND
  elif len(sys.argv) < 2:
    print ('Usage: python do.py [command] [other arguments]')
    exit(1)
  else:
    command = sys.argv[1]

  if command not in commands:
    print ('Command ' + command + ' not recognized by do.')
    exit(1)

  print ('* do.py performing the "%s" command.' % command)
  commands[command]()
